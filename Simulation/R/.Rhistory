delta <- ((2/(m+1))^phi) * ((phi-1)/phi)
#-----------------------------------------------------------------------
# Resultados importantes
#-----------------------------------------------------------------------
EY =  ((phi/(phi-1))/(1- exp(-delta))) * derivada_gama(beta, nu, X, Z, 2, 0)
EYlog = (   (1/(phi-1))/ (1 - exp(-delta)))*( derivada_gama(beta, nu, X, Z, 2, 1) + log(phi/(phi-1)) * derivada_gama(beta, nu, X, Z, 2, 0) )
EYlog2 = (  (  (1/phi)*(1/(phi-1)) )/(1- exp(-delta))  ) * ( 2 * log(phi/(phi-1)) * derivada_gama(beta, nu, X, Z, 2, 1) + (  log(phi/(phi-1))  )^(2) * derivada_gama(beta, nu, X, Z, 2, 0) + derivada_gama(beta, nu, X, Z, 2, 2) )
#-----------------------------------------------------------------------
# derivada de segunda ordem em funcao de m
h1 <- (   exp(-delta) * (2/(m+1))^(2*phi) * ( (phi-1)/(m+1) )^(2)-
exp(-delta) * (2/(m+1))^(phi) * (phi/(m+1)) * ((phi-1)/(m+1)) +
exp(-2*delta) * (2/(m+1))^(phi) * (phi/(m+1)) * ((phi-1)/(m+1)) -
exp(-delta) * (2/(m+1))^(phi) * ((phi-1)/((m+1)^2)) +
exp(-2*delta) * (2/(m+1))^(phi) * ((phi-1)/((m+1)^2))
)/ ( (1-exp(-delta))^2 )
# derivada de segunda ordem em funcao de phi
h3 <- -((
-exp(-delta) * (2/(m+1))^(2*phi) * ((phi-1)/phi)^(2) * (log( 2/(m+1)))^(2) -
2 * exp(-delta) * (2/(m+1))^(2*phi) * ((phi-1)/phi) * (1/(phi^2)) * log(2/(m+1)) +
exp(-delta) * (2/(m+1))^(phi) * ((phi-1)/phi) * (log(2/(m+1)) )^(2) -
exp(-2*delta) * (2/(m+1))^(phi) * ((phi-1)/phi) * (log(2/(m+1)) )^(2) +
2 * exp(-delta) * (2/(m+1))^(phi) * (1/(phi^2)) * log(2/(m+1)) -
2 * exp(-2*delta) * (2/(m+1))^(phi) * (1/(phi^2)) * log(2/(m+1)) -
exp(-delta) * (2/(m+1))^(2*phi) * (1/(phi^2))^(2) -
exp(-delta) * (2/(m+1))^(phi) * (2/(phi^3)) +
exp(-2*delta) * (2/(m+1))^(phi) * (2/(phi^3))
)/( ( 1-exp(-delta))^2 ) )
# derivada cruzada
h2 <- ( -exp(-delta) * (2/(m+1))^(2*phi) * log(2/(m+1)) * ((phi-1)/phi) * ((phi-1)/(m+1)) -
exp(-delta) * (2/(m+1))^(2*phi) * (1/(phi^2)) * ((phi-1)/(m+1)) +
exp(-delta) * (2/(m+1))^(phi) * log(2/(m+1)) * ((phi-1)/(m+1)) -
exp(-2*delta) * (2/(m+1))^(phi) * log(2/(m+1)) * ((phi-1)/(m+1)) +
exp(-delta) * (2/(m+1))^(phi) * (1/(m+1)) -
exp(-2*delta) * (2/(m+1))^(phi) * (1/(m+1))
)/( (1-exp(-delta))^2)
# ( - Esperanca das derivadas de segunda ordem)
# eperanca em funcao de m
ES <- as.vector(
- (phi/((m+1)^2)) + ( (phi-1)/((m+1)^2)) * EY + ((phi-1)/(m+1))*(phi/(m+1)) * EY - h1
)
# esperanca da derivada cruzada
ED <- as.vector(
(1/(m+1)) - (1/(m+1)) * EY - ((phi-1)/(m+1)) * EYlog - h2
)
# esperanca de phi
EV <- as.vector(
(1/((phi-1)^2)) + ((phi-1)/phi) * EYlog2 + (2/(phi^2))* EYlog - (2/(phi^3)) * EY -  h3
)
#-----------------------------------------------------------------------
H = diag(as.vector(ES))%*%(mT^2)
C = mT%*%diag(as.vector(ED))%*%mC
Q = diag(as.vector(EV))%*%(mC^2)
Kbb <- t(X)%*%(H)%*%X
Kbn <- t(X)%*%(C)%*%Z
Knn <- t(Z)%*%(Q)%*%Z
#---------------------------------------------------------------------------
Ktheta<-rbind(
cbind(Kbb,(Kbn)),
cbind(t(Kbn),Knn)
)
return(Ktheta)
}
#-----------------------------------------------------------------------------
vtheta=c(beta, nu)
p <- length(beta)
q <- length(nu)
k <- length(vtheta)
R = 5000
B <- 1000
mreplicas = matrix(0, nrow=R,ncol=k)
R = 500
B <- 100
mreplicas = matrix(0, nrow=R,ncol=k)
thetaboot = matrix(0, nrow=R,ncol= k)
contIC90 = contIC95 = contIC99 <-  matrix(0, nrow=R,ncol=k)
cont0=0 # contador para nao convergencia
z_c90 <-qnorm(1-0.1/2)
z_c95 <-qnorm(1-0.05/2)
z_c99 <-qnorm(1-0.01/2)
#-----------------------------------------------------------------------------
l=1 # inicia a interação
if(p==1){
X<-cbind(rep(1,n))
}else{
X <- cbind(1, replicate(p-1, runif(n)))
}
if(q==1){
Z = cbind(rep(1,n))
l=1 # inicia a interação
if(p==1){
X<-cbind(rep(1,n))
}else{
X <- cbind(1, replicate(p-1, runif(n)))
}
if(q==1){
Z = cbind(rep(1,n))
}else{
Z = cbind(1, replicate(q-1, runif(n)))
}
y=simu.WeibullT(n, beta, nu, X, Z)
#hist(y)
#---------------------------------------------------------------------------
if(max(abs(y))!=1){
##------------------------ Chute Inicial----------------------------------
ynew <- link1$linkfun( (y+1)/2)
ajuste1 <- lm(ynew ~ X+0)
mqo=ajuste1$coef # minimos quadrados ordinarios
# tentativas ajuste2
if(q == 1){
s2 <- var(ynew)#(sum(y - mean(y))^2)/(n-1) # variancia amostral
}else{
s2<- 1/(summary(ajuste1)[[6]]^2)
}
ajuste2 = as.numeric(rep(s2,q)) # tentativa 1
#ynew2<-(as.vector((X%*%mqo)))^2/as.numeric(var(y))
#ajuste2 = lm(ynew2~Z+0) # tentativa 2
#start=c(ajuste1$coefficients, ajuste2$coefficients)
start = c(as.numeric(ajuste1$coefficients), ajuste2)
##------------------------------------------------------------------------
#-------------------------------------------------------------------------
fit <- try(optim(start, fn, gr = escore, method = "BFGS", hessian = T,
control = list(fnscale = -1, maxit = 3000, reltol = 1e-6)), silent=T)
#sqrt(diag(-solve(fit$hessian)))
TesteInvF <- try(solve(Fisher(fit$par, data = y)), silent = T)
#sqrt(diag(-solve(fit$hessian)))
if( sum(class(TesteInvF) != "try-error") == 2 ){
if((class(fit) != "try-error") ){
if((fit$conv==0 & (sum(is.na(sqrt(diag(   solve(  Fisher(fit$par, data = y)) ))  ) ) == 0))){
#
mreplicas[l,]=c(fit$par)
H1 <- sqrt(diag(solve(Fisher(fit$par, data = y))) ) # Informacao de Fisher esperada
#H2 <- sqrt(diag(-solve( fit$hessian ) )) # optim()
IC90<-cbind(fit$par-z_c90*H1,fit$par+z_c90*H1)
IC95<-cbind(fit$par-z_c95*H1,fit$par+z_c95*H1)
IC99<-cbind(fit$par-z_c99*H1,fit$par+z_c99*H1)
Theta<-c(beta,nu)
nTheta <-length(Theta)
for(a in 1:nTheta){
contIC90[l,a]<- between(Theta[a], IC90[a,1], IC90[a, 2])
contIC95[l,a]<- between(Theta[a], IC95[a,1], IC95[a, 2])
contIC99[l,a]<- between(Theta[a], IC99[a,1], IC99[a, 2])
}
#---------------------------------------------------------------------
# bootstrap
boot_temp <- matrix(0, ncol = k, nrow = B)
#contIC90boot = contIC95boot = contIC99boot <- matrix(0, nrow=B,ncol=k)
cont_b <- 1
while (cont_b <= B) {
#beta <- theta[1:p]
beta_boot <- mreplicas[l,1:p]
nu_boot <- mreplicas[l,(p+1):length(vtheta)]
y=simu.WeibullT(n, beta_boot, nu_boot, X, Z)
if(max(abs(y))!=1){
fit_boot <- try(optim(start, fn, method = "BFGS", hessian = T,
control = list(fnscale = -1, maxit = 3000, reltol = 1e-6)), silent=T)
#
#if( sum(class(TesteInvF) != "try-error") == 2 ){
if((class(fit_boot) != "try-error") ){
#if((fit_boot$conv==0 & (sum(is.na(sqrt(diag(   solve(  Fisher(fit$par, data = y)) ))  ) ) == 0))){
boot_temp[cont_b,] <- c(fit_boot$par)
Hboot <- sqrt(diag(solve(Fisher(fit_boot$par, data = y))) ) # Informacao de Fisher esperada
IC90boot<-cbind(fit_boot$par-z_c90*Hboot,fit_boot$par+z_c90*Hboot)
IC95boot<-cbind(fit_boot$par-z_c95*Hboot,fit_boot$par+z_c95*Hboot)
IC99boot<-cbind(fit_boot$par-z_c99*Hboot,fit_boot$par+z_c99*Hboot)
Theta<-c(beta,nu)
nTheta <-length(Theta)
for(a in 1:nTheta){
contIC90boot[cont_b,a]<- between(Theta[a], IC90boot[a,cont_b], IC90boot[a, 2])
contIC95boot[cont_b,a]<- between(Theta[a], IC95boot[a,cont_b], IC95boot[a, 2])
contIC99boot[cont_b,a]<- between(Theta[a], IC99boot[a,cont_b], IC99boot[a, 2])
}
cont_b = cont_b + 1
#print(cont_b)
#} # fim if
} # fim if
#}# fim if
}
} # fim while boot
thetaboot[l,] <- 2*mreplicas[l,] - apply(boot_temp, 2, mean)
l=l+1
print(l)
#if((100*l/R)%%10 == 0)
#  print(c(100*l/R, "%"), quote = F)
}
} # final do if(class(fit))---------------------------------------------
}
}
}#fim do while
head(mreplicas)
l=1 # inicia a interação
if(p==1){
X<-cbind(rep(1,n))
}else{
X <- cbind(1, replicate(p-1, runif(n)))
}
if(q==1){
Z = cbind(rep(1,n))
}else{
Z = cbind(1, replicate(q-1, runif(n)))
}
y=simu.WeibullT(n, beta, nu, X, Z)
#hist(y)
ynew <- link1$linkfun( (y+1)/2)
ajuste1 <- lm(ynew ~ X+0)
mqo=ajuste1$coef # minimos quadrados ordinarios
# tentativas ajuste2
if(q == 1){
s2 <- var(ynew)#(sum(y - mean(y))^2)/(n-1) # variancia amostral
}else{
s2<- 1/(summary(ajuste1)[[6]]^2)
}
ajuste2 = as.numeric(rep(s2,q)) # tentativa 1
#ynew2<-(as.vector((X%*%mqo)))^2/as.numeric(var(y))
#ajuste2 = lm(ynew2~Z+0) # tentativa 2
#start=c(ajuste1$coefficients, ajuste2$coefficients)
start = c(as.numeric(ajuste1$coefficients), ajuste2)
##------------------------------------------------------------------------
#-------------------------------------------------------------------------
fit <- try(optim(start, fn, gr = escore, method = "BFGS", hessian = T,
control = list(fnscale = -1, maxit = 3000, reltol = 1e-6)), silent=T)
TesteInvF <- try(solve(Fisher(fit$par, data = y)), silent = T)
#sqrt(diag(-solve(fit$hessian)))
if( sum(class(TesteInvF) != "try-error") == 2 ){
}
mreplicas[l,]=c(fit$par)
mreplicas
H1 <- sqrt(diag(solve(Fisher(fit$par, data = y))) ) # Informacao de Fisher esperada
IC90<-cbind(fit$par-z_c90*H1,fit$par+z_c90*H1)
IC95<-cbind(fit$par-z_c95*H1,fit$par+z_c95*H1)
IC99<-cbind(fit$par-z_c99*H1,fit$par+z_c99*H1)
Theta<-c(beta,nu)
nTheta <-length(Theta)
for(a in 1:nTheta){
contIC90[l,a]<- between(Theta[a], IC90[a,1], IC90[a, 2])
contIC95[l,a]<- between(Theta[a], IC95[a,1], IC95[a, 2])
contIC99[l,a]<- between(Theta[a], IC99[a,1], IC99[a, 2])
}
boot_temp <- matrix(0, ncol = k, nrow = B)
contIC90boot = contIC95boot = contIC99boot <- matrix(0, nrow=B,ncol=k)
cont_b <- 1
while (cont_b <= B) {
#beta <- theta[1:p]
beta_boot <- mreplicas[l,1:p]
nu_boot <- mreplicas[l,(p+1):length(vtheta)]
y=simu.WeibullT(n, beta_boot, nu_boot, X, Z)
if(max(abs(y))!=1){
fit_boot <- try(optim(start, fn, method = "BFGS", hessian = T,
control = list(fnscale = -1, maxit = 3000, reltol = 1e-6)), silent=T)
#
#if( sum(class(TesteInvF) != "try-error") == 2 ){
if((class(fit_boot) != "try-error") ){
#if((fit_boot$conv==0 & (sum(is.na(sqrt(diag(   solve(  Fisher(fit$par, data = y)) ))  ) ) == 0))){
boot_temp[cont_b,] <- c(fit_boot$par)
Hboot <- sqrt(diag(solve(Fisher(fit_boot$par, data = y))) ) # Informacao de Fisher esperada
IC90boot<-cbind(fit_boot$par-z_c90*Hboot,fit_boot$par+z_c90*Hboot)
IC95boot<-cbind(fit_boot$par-z_c95*Hboot,fit_boot$par+z_c95*Hboot)
IC99boot<-cbind(fit_boot$par-z_c99*Hboot,fit_boot$par+z_c99*Hboot)
Theta<-c(beta,nu)
nTheta <-length(Theta)
for(a in 1:nTheta){
contIC90boot[cont_b,a]<- between(Theta[a], IC90boot[a,cont_b], IC90boot[a, 2])
contIC95boot[cont_b,a]<- between(Theta[a], IC95boot[a,cont_b], IC95boot[a, 2])
contIC99boot[cont_b,a]<- between(Theta[a], IC99boot[a,cont_b], IC99boot[a, 2])
}
cont_b = cont_b + 1
#print(cont_b)
#} # fim if
} # fim if
#}# fim if
}
}
boot_temp <- matrix(0, ncol = k, nrow = B)
cont_b <- 1
while (cont_b <= B) {
#beta <- theta[1:p]
beta_boot <- mreplicas[l,1:p]
nu_boot <- mreplicas[l,(p+1):length(vtheta)]
y=simu.WeibullT(n, beta_boot, nu_boot, X, Z)
if(max(abs(y))!=1){
fit_boot <- try(optim(start, fn, method = "BFGS", hessian = T,
control = list(fnscale = -1, maxit = 3000, reltol = 1e-6)), silent=T)
#
#if( sum(class(TesteInvF) != "try-error") == 2 ){
if((class(fit_boot) != "try-error") ){
#if((fit_boot$conv==0 & (sum(is.na(sqrt(diag(   solve(  Fisher(fit$par, data = y)) ))  ) ) == 0))){
boot_temp[cont_b,] <- c(fit_boot$par)
#Hboot <- sqrt(diag(solve(Fisher(fit_boot$par, data = y))) ) # Informacao de Fisher esperada
#IC90boot<-cbind(fit_boot$par-z_c90*Hboot,fit_boot$par+z_c90*Hboot)
#IC95boot<-cbind(fit_boot$par-z_c95*Hboot,fit_boot$par+z_c95*Hboot)
#IC99boot<-cbind(fit_boot$par-z_c99*Hboot,fit_boot$par+z_c99*Hboot)
#Theta<-c(beta,nu)
#nTheta <-length(Theta)
#for(a in 1:nTheta){
#contIC90boot[cont_b,a]<- between(Theta[a], IC90boot[a,cont_b], IC90boot[a, 2])
#contIC95boot[cont_b,a]<- between(Theta[a], IC95boot[a,cont_b], IC95boot[a, 2])
#contIC99boot[cont_b,a]<- between(Theta[a], IC99boot[a,cont_b], IC99boot[a, 2])
#}
cont_b = cont_b + 1
#print(cont_b)
#} # fim if
} # fim if
#}# fim if
}
}
thetaboot[l,] <- 2*mreplicas[l,] - apply(boot_temp, 2, mean)
thetaboot
head(thetaboot)
media_boot=apply(thetaboot,2,mean) # estimativa de Monte Carlo
media_boot
q()
library(tidyverse)
# Questao 1
num1 = scan("", nmax=1)
num3 = scan("", nmax=1)
#-----------------------------------------------------------------
# Questao 2
sexo = scan(what = "character", nmax = 1)
altura = scan("",nmax=1)
A = scan("", nmax = 1)
C = scan("", nmax = 1)
#-----------------------------------------------------------------
# Questao 5
n = scan("", nmax = 1)
cont = 1
while (cont <= n) {
var = var*cont
cont = cont + 1
}
print(var)
salarioM = 1302
i = 1
while (i <= 10){
cpf = scan("", nmax = 1)
dependentes = scan("", nmax = 1)
renda = scan("", nmax = 1)
# calculo do imposto
if(renda<=2){
imposto = "Isento"
}else{
if(renda > 2 & renda <=3){
imposto = salarioM*renda*0.05
}
if(renda > 3 & renda <=5){
imposto = salarioM*renda*0.10
}
if(renda > 5 & renda <=7){
imposto = salarioM*renda*0.15
}
if(renda > 7 ){
imposto = salarioM*renda*0.2
}
if(dependentes >0){
imposto = imposto - dependentes*(salarioM*0.05)
}
}
cat("O imposto a ser pago: ", imposto)
i = i + 1
}
soma = 0
i = 0
while (i < n) {
cat("\n Insira os valores de n e x: \n")
n = scan("", nmax = 1)
x = scan("", nmax = 1)
if(n - round(n) == 0 & n > 0){
cat("\n n e um numero inteiro e positivo \n")
while(i <= n){
soma = soma + x^i
i = i + 1
}
cat("h(x,n) = ",soma)
}else{
cat("Insira um valor n: ")
}
i = i + 1
}
num2 = scan("", nmax=1)
# os numeros devem ser diferentes
if((num1 != num2) & (num1!=num3) & (num2!=num3)){
cat("A ordem inserida de numeros inteiros: \n", num1,num2,num3)
# se num1 for o maior numero, as possiveis combinacoes sao: 123 ou 132.
# a primeira posicao da sequencia e 1, a segunda posicao pode ser
# os numeros 2 ou 3.
if(num1 > num2 & num1 > num3){
if(num2 > num3){
cat("\n A ordem descrescente: ", num1, num2, num)
}else{
cat("\n A ordem decrescente: ", num1, num3,num2)
}
}
# se num2 for o maior numero, as possiveis combinacoes sao: 213 ou 231.
# a primeira posicao da sequencia e 2, a segunda posicao pode ser
# os numeros 1 ou 3.
if(num2 > num3 & num2 > num1){
if(num1 > num3){
cat("\n A ordem descrescente: ", num2, num1, num3)
}else{
cat("\n A ordem decrescente: ", num2,num3,num1)
}
}
# se num3 for o maior numero, as possiveis combinacoes sao: 321 ou 312.
# a primeira posicao da sequencia e 3, a segunda posicao pode ser
# os numeros 2 ou 1.
if(num3 > num2 & num3 > num1){
if(num2 > num1){
cat("\n A ordem descrescente: ", num3, num2, num1)
}else{
cat("\n A ordem decrescente: ", num3,num1,num2)
}
}
}
#-----------------------------------------------------------------
# Questao 2
sexo = scan(what = "character", nmax = 1)
altura = scan("",nmax=1)
A = scan("", nmax = 1)
C = scan("", nmax = 1)
a
A = scan("", nmax = 1)
B = scan("", nmax = 1)
C = scan("", nmax = 1)
# cada lado for menor que a soma dos demais
# lado A
if(A < B + C | B < A + C | C < B + A){ # compoe um triangulo
if(A == B & B == C){ # todos os lados iguais
cat("Tringulo equilatero")
}
if(A == B & A != C | B == C & B!=A | C==A & C != B){ # um lado diferente
cat("Triangulo isosceles")
}
if(A != B & B != C){ # todos os lados diferentes
cat("Triangulo escaleno")
}
}else{
cat("Nao compoe um triangulo")
}
#-----------------------------------------------------------------
# Questao 5
n = scan("", nmax = 1)
var = 1
cont = 1
while (cont <= n) {
var = var*cont
cont = cont + 1
}
print(var)
salarioM = 1302
i = 1
while (i <= 10){
cpf = scan("", nmax = 1)
dependentes = scan("", nmax = 1)
renda = scan("", nmax = 1)
# calculo do imposto
if(renda<=2){
imposto = "Isento"
}else{
if(renda > 2 & renda <=3){
imposto = salarioM*renda*0.05
}
if(renda > 3 & renda <=5){
imposto = salarioM*renda*0.10
}
if(renda > 5 & renda <=7){
imposto = salarioM*renda*0.15
}
if(renda > 7 ){
imposto = salarioM*renda*0.2
}
if(dependentes >0){
imposto = imposto - dependentes*(salarioM*0.05)
}
}
cat("O imposto a ser pago: ", imposto)
i = i + 1
}
auth-pam-sessions-close=1
sessionInfo()
sessioninfo::session_info()
sessioninfo::external_info()
sessioninfo::os_name()
sessioninfo::session_diff()
session-timeout-kill-hours=48
#install.packages("gamlss")
library(gamlss)
library(hnp)
q()
getwd()
setwd("C:/Users/giord/Dropbox/Orientação Giordanna/Simulações/nlminb/cenarioE")
library(tidyverse)
library(moments)
source("random_weibullT.R")
source("otimizacaoWT.R")
set.seed(2)
e1 <- teste_otimizacao(20,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e2 <- teste_otimizacao(30,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e3 <- teste_otimizacao(40,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e4 <- teste_otimizacao(50,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e5 <- teste_otimizacao(100,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e6 <- teste_otimizacao(200,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e7 <- teste_otimizacao(500,c(0.5, -1, -0.5),c(1.5,0.5),link.mu = "logit",link.phi = "log", 10000)
e1
e2
e3
e4
e5
e6
e7
save.image("eNEW_logit_log_Simulacao_R10000.RData")
e1
e1$mediaMC
q()
q()
